/* tslint:disable */
/* eslint-disable */
/**
 * harena
 * harena
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Argent
 */
export interface Argent {
    /**
     * 
     * @type {string}
     * @memberof Argent
     */
    't'?: string;
    /**
     * 
     * @type {string}
     * @memberof Argent
     */
    'nom'?: string;
    /**
     * 
     * @type {number}
     * @memberof Argent
     */
    'valeur_comptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof Argent
     */
    'devise'?: Devise;
    /**
     * 
     * @type {string}
     * @memberof Argent
     */
    'date_d_ouverture'?: string;
    /**
     * 
     * @type {string}
     * @memberof Argent
     */
    'type'?: ArgentTypeEnum;
}

export const ArgentTypeEnum = {
    Dette: 'DETTE',
    Creance: 'CREANCE',
    Autres: 'AUTRES'
} as const;

export type ArgentTypeEnum = typeof ArgentTypeEnum[keyof typeof ArgentTypeEnum];

/**
 * 
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
    /**
     * 
     * @type {string}
     * @memberof BadRequestException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BadRequestException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Devise
 */
export interface Devise {
    /**
     * 
     * @type {string}
     * @memberof Devise
     */
    'nom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Devise
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Exception
 */
export interface Exception {
    /**
     * 
     * @type {string}
     * @memberof Exception
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exception
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FluxArgent
 */
export interface FluxArgent {
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    't'?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    'nom'?: string;
    /**
     * 
     * @type {number}
     * @memberof FluxArgent
     */
    'valeur_comptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof FluxArgent
     */
    'devise'?: Devise;
    /**
     * 
     * @type {Argent}
     * @memberof FluxArgent
     */
    'argent'?: Argent;
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    'debut'?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    'fin'?: string;
    /**
     * 
     * @type {number}
     * @memberof FluxArgent
     */
    'flux_mensuel'?: number;
    /**
     * 
     * @type {number}
     * @memberof FluxArgent
     */
    'date_d_operation'?: number;
}
/**
 * 
 * @export
 * @interface FluxImpossibles
 */
export interface FluxImpossibles {
    /**
     * 
     * @type {string}
     * @memberof FluxImpossibles
     */
    'nom_argent'?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxImpossibles
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof FluxImpossibles
     */
    'valeur_argent'?: number;
    /**
     * 
     * @type {Array<FluxArgent>}
     * @memberof FluxImpossibles
     */
    'flux_argents'?: Array<FluxArgent>;
}
/**
 * 
 * @export
 * @interface GetPatrimoineFluxImpossibles200Response
 */
export interface GetPatrimoineFluxImpossibles200Response {
    /**
     * 
     * @type {Array<FluxImpossibles>}
     * @memberof GetPatrimoineFluxImpossibles200Response
     */
    'data'?: Array<FluxImpossibles>;
}
/**
 * 
 * @export
 * @interface GetPatrimoinePossessions200Response
 */
export interface GetPatrimoinePossessions200Response {
    /**
     * 
     * @type {Array<PossessionAvecType>}
     * @memberof GetPatrimoinePossessions200Response
     */
    'data'?: Array<PossessionAvecType>;
}
/**
 * 
 * @export
 * @interface GetPatrimoines200Response
 */
export interface GetPatrimoines200Response {
    /**
     * 
     * @type {Array<Patrimoine>}
     * @memberof GetPatrimoines200Response
     */
    'data'?: Array<Patrimoine>;
}
/**
 * 
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
    /**
     * 
     * @type {string}
     * @memberof InternalServerException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Materiel
 */
export interface Materiel {
    /**
     * 
     * @type {string}
     * @memberof Materiel
     */
    't'?: string;
    /**
     * 
     * @type {string}
     * @memberof Materiel
     */
    'nom'?: string;
    /**
     * 
     * @type {number}
     * @memberof Materiel
     */
    'valeur_comptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof Materiel
     */
    'devise'?: Devise;
    /**
     * 
     * @type {string}
     * @memberof Materiel
     */
    'date_d_acquisition'?: string;
    /**
     * 
     * @type {number}
     * @memberof Materiel
     */
    'taux_dappreciation_annuel'?: number;
}
/**
 * 
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
    /**
     * 
     * @type {string}
     * @memberof NotAuthorizedException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotAuthorizedException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Patrimoine
 */
export interface Patrimoine {
    /**
     * 
     * @type {string}
     * @memberof Patrimoine
     */
    'nom'?: string;
    /**
     * 
     * @type {Personne}
     * @memberof Patrimoine
     */
    'possesseur'?: Personne;
    /**
     * 
     * @type {string}
     * @memberof Patrimoine
     */
    't'?: string;
    /**
     * 
     * @type {number}
     * @memberof Patrimoine
     */
    'valeur_comptable'?: number;
}
/**
 * 
 * @export
 * @interface Personne
 */
export interface Personne {
    /**
     * 
     * @type {string}
     * @memberof Personne
     */
    'nom'?: string;
}
/**
 * 
 * @export
 * @interface Possession
 */
export interface Possession {
    /**
     * 
     * @type {string}
     * @memberof Possession
     */
    't'?: string;
    /**
     * 
     * @type {string}
     * @memberof Possession
     */
    'nom'?: string;
    /**
     * 
     * @type {number}
     * @memberof Possession
     */
    'valeur_comptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof Possession
     */
    'devise'?: Devise;
}
/**
 * 
 * @export
 * @interface PossessionAvecType
 */
export interface PossessionAvecType {
    /**
     * 
     * @type {string}
     * @memberof PossessionAvecType
     */
    'type'?: PossessionAvecTypeTypeEnum;
    /**
     * 
     * @type {Argent}
     * @memberof PossessionAvecType
     */
    'argent'?: Argent;
    /**
     * 
     * @type {Materiel}
     * @memberof PossessionAvecType
     */
    'materiel'?: Materiel;
    /**
     * 
     * @type {FluxArgent}
     * @memberof PossessionAvecType
     */
    'flux_argent'?: FluxArgent;
}

export const PossessionAvecTypeTypeEnum = {
    Argent: 'ARGENT',
    Materiel: 'MATERIEL',
    Fluxargent: 'FLUXARGENT'
} as const;

export type PossessionAvecTypeTypeEnum = typeof PossessionAvecTypeTypeEnum[keyof typeof PossessionAvecTypeTypeEnum];

/**
 * 
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
    /**
     * 
     * @type {string}
     * @memberof TooManyRequestsException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TooManyRequestsException
     */
    'message'?: string;
}

/**
 * PatrimoineApi - axios parameter creator
 * @export
 */
export const PatrimoineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary met à jour les patrimoines si le nom est donné, sinon on le crée
         * @param {GetPatrimoines200Response} [getPatrimoines200Response] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdatePatrimoines: async (getPatrimoines200Response?: GetPatrimoines200Response, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/patrimoines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPatrimoines200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary obtenir le patrimoine demandé
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineByNom: async (nomPatrimoine: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getPatrimoineByNom', 'nomPatrimoine', nomPatrimoine)
            const localVarPath = `/patrimoines/{nom_patrimoine}`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary obtenir une liste paginée des patrimoines
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoines: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/patrimoines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatrimoineApi - functional programming interface
 * @export
 */
export const PatrimoineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatrimoineApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary met à jour les patrimoines si le nom est donné, sinon on le crée
         * @param {GetPatrimoines200Response} [getPatrimoines200Response] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdatePatrimoines(getPatrimoines200Response?: GetPatrimoines200Response, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPatrimoines200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdatePatrimoines(getPatrimoines200Response, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineApi.crupdatePatrimoines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary obtenir le patrimoine demandé
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoineByNom(nomPatrimoine: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Patrimoine>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoineByNom(nomPatrimoine, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineApi.getPatrimoineByNom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary obtenir une liste paginée des patrimoines
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoines(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPatrimoines200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoines(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineApi.getPatrimoines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PatrimoineApi - factory interface
 * @export
 */
export const PatrimoineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatrimoineApiFp(configuration)
    return {
        /**
         * 
         * @summary met à jour les patrimoines si le nom est donné, sinon on le crée
         * @param {GetPatrimoines200Response} [getPatrimoines200Response] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdatePatrimoines(getPatrimoines200Response?: GetPatrimoines200Response, options?: any): AxiosPromise<GetPatrimoines200Response> {
            return localVarFp.crupdatePatrimoines(getPatrimoines200Response, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary obtenir le patrimoine demandé
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineByNom(nomPatrimoine: string, options?: any): AxiosPromise<Patrimoine> {
            return localVarFp.getPatrimoineByNom(nomPatrimoine, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary obtenir une liste paginée des patrimoines
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoines(page?: number, pageSize?: number, options?: any): AxiosPromise<GetPatrimoines200Response> {
            return localVarFp.getPatrimoines(page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatrimoineApi - object-oriented interface
 * @export
 * @class PatrimoineApi
 * @extends {BaseAPI}
 */
export class PatrimoineApi extends BaseAPI {
    /**
     * 
     * @summary met à jour les patrimoines si le nom est donné, sinon on le crée
     * @param {GetPatrimoines200Response} [getPatrimoines200Response] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineApi
     */
    public crupdatePatrimoines(getPatrimoines200Response?: GetPatrimoines200Response, options?: RawAxiosRequestConfig) {
        return PatrimoineApiFp(this.configuration).crupdatePatrimoines(getPatrimoines200Response, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary obtenir le patrimoine demandé
     * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineApi
     */
    public getPatrimoineByNom(nomPatrimoine: string, options?: RawAxiosRequestConfig) {
        return PatrimoineApiFp(this.configuration).getPatrimoineByNom(nomPatrimoine, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary obtenir une liste paginée des patrimoines
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineApi
     */
    public getPatrimoines(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return PatrimoineApiFp(this.configuration).getPatrimoines(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PossessionApi - axios parameter creator
 * @export
 */
export const PossessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary met à jour une possession d\'un patrimoine si le nom existe, sinon on le crée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {GetPatrimoinePossessions200Response} [getPatrimoinePossessions200Response] liste de possessions à ajouter ou à modifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdatePatrimoinePossessions: async (nomPatrimoine: string, page?: number, pageSize?: number, getPatrimoinePossessions200Response?: GetPatrimoinePossessions200Response, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('crupdatePatrimoinePossessions', 'nomPatrimoine', nomPatrimoine)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPatrimoinePossessions200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary effacer un patrimoine d\'une possession
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePatrimoinePossessionByNom: async (nomPatrimoine: string, nomPossession: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('deletePatrimoinePossessionByNom', 'nomPatrimoine', nomPatrimoine)
            // verify required parameter 'nomPossession' is not null or undefined
            assertParamExists('deletePatrimoinePossessionByNom', 'nomPossession', nomPossession)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions/{nom_possession}`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)))
                .replace(`{${"nom_possession"}}`, encodeURIComponent(String(nomPossession)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary obtenir la possession demandée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoinePossessionByNom: async (nomPatrimoine: string, nomPossession: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getPatrimoinePossessionByNom', 'nomPatrimoine', nomPatrimoine)
            // verify required parameter 'nomPossession' is not null or undefined
            assertParamExists('getPatrimoinePossessionByNom', 'nomPossession', nomPossession)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions/{nom_possession}`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)))
                .replace(`{${"nom_possession"}}`, encodeURIComponent(String(nomPossession)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary obtenir une liste paginée des possessions d\'un patrimoine
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoinePossessions: async (nomPatrimoine: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getPatrimoinePossessions', 'nomPatrimoine', nomPatrimoine)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PossessionApi - functional programming interface
 * @export
 */
export const PossessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PossessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary met à jour une possession d\'un patrimoine si le nom existe, sinon on le crée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {GetPatrimoinePossessions200Response} [getPatrimoinePossessions200Response] liste de possessions à ajouter ou à modifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdatePatrimoinePossessions(nomPatrimoine: string, page?: number, pageSize?: number, getPatrimoinePossessions200Response?: GetPatrimoinePossessions200Response, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPatrimoinePossessions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdatePatrimoinePossessions(nomPatrimoine, page, pageSize, getPatrimoinePossessions200Response, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PossessionApi.crupdatePatrimoinePossessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary effacer un patrimoine d\'une possession
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePatrimoinePossessionByNom(nomPatrimoine: string, nomPossession: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePatrimoinePossessionByNom(nomPatrimoine, nomPossession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PossessionApi.deletePatrimoinePossessionByNom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary obtenir la possession demandée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoinePossessionByNom(nomPatrimoine: string, nomPossession: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PossessionAvecType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoinePossessionByNom(nomPatrimoine, nomPossession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PossessionApi.getPatrimoinePossessionByNom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary obtenir une liste paginée des possessions d\'un patrimoine
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoinePossessions(nomPatrimoine: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPatrimoinePossessions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoinePossessions(nomPatrimoine, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PossessionApi.getPatrimoinePossessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PossessionApi - factory interface
 * @export
 */
export const PossessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PossessionApiFp(configuration)
    return {
        /**
         * 
         * @summary met à jour une possession d\'un patrimoine si le nom existe, sinon on le crée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {GetPatrimoinePossessions200Response} [getPatrimoinePossessions200Response] liste de possessions à ajouter ou à modifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdatePatrimoinePossessions(nomPatrimoine: string, page?: number, pageSize?: number, getPatrimoinePossessions200Response?: GetPatrimoinePossessions200Response, options?: any): AxiosPromise<GetPatrimoinePossessions200Response> {
            return localVarFp.crupdatePatrimoinePossessions(nomPatrimoine, page, pageSize, getPatrimoinePossessions200Response, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary effacer un patrimoine d\'une possession
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePatrimoinePossessionByNom(nomPatrimoine: string, nomPossession: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePatrimoinePossessionByNom(nomPatrimoine, nomPossession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary obtenir la possession demandée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoinePossessionByNom(nomPatrimoine: string, nomPossession: string, options?: any): AxiosPromise<PossessionAvecType> {
            return localVarFp.getPatrimoinePossessionByNom(nomPatrimoine, nomPossession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary obtenir une liste paginée des possessions d\'un patrimoine
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoinePossessions(nomPatrimoine: string, page?: number, pageSize?: number, options?: any): AxiosPromise<GetPatrimoinePossessions200Response> {
            return localVarFp.getPatrimoinePossessions(nomPatrimoine, page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PossessionApi - object-oriented interface
 * @export
 * @class PossessionApi
 * @extends {BaseAPI}
 */
export class PossessionApi extends BaseAPI {
    /**
     * 
     * @summary met à jour une possession d\'un patrimoine si le nom existe, sinon on le crée
     * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {GetPatrimoinePossessions200Response} [getPatrimoinePossessions200Response] liste de possessions à ajouter ou à modifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PossessionApi
     */
    public crupdatePatrimoinePossessions(nomPatrimoine: string, page?: number, pageSize?: number, getPatrimoinePossessions200Response?: GetPatrimoinePossessions200Response, options?: RawAxiosRequestConfig) {
        return PossessionApiFp(this.configuration).crupdatePatrimoinePossessions(nomPatrimoine, page, pageSize, getPatrimoinePossessions200Response, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary effacer un patrimoine d\'une possession
     * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PossessionApi
     */
    public deletePatrimoinePossessionByNom(nomPatrimoine: string, nomPossession: string, options?: RawAxiosRequestConfig) {
        return PossessionApiFp(this.configuration).deletePatrimoinePossessionByNom(nomPatrimoine, nomPossession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary obtenir la possession demandée
     * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {string} nomPossession nom de la possession avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PossessionApi
     */
    public getPatrimoinePossessionByNom(nomPatrimoine: string, nomPossession: string, options?: RawAxiosRequestConfig) {
        return PossessionApiFp(this.configuration).getPatrimoinePossessionByNom(nomPatrimoine, nomPossession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary obtenir une liste paginée des possessions d\'un patrimoine
     * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PossessionApi
     */
    public getPatrimoinePossessions(nomPatrimoine: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return PossessionApiFp(this.configuration).getPatrimoinePossessions(nomPatrimoine, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectionFutureApi - axios parameter creator
 * @export
 */
export const ProjectionFutureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary obtenir une liste des flux impossibles du patrimoine dans une intervalle donnée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} [debut] 
         * @param {string} [fin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineFluxImpossibles: async (nomPatrimoine: string, debut?: string, fin?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getPatrimoineFluxImpossibles', 'nomPatrimoine', nomPatrimoine)
            const localVarPath = `/patrimoines/{nom_patrimoine}/flux-impossibles`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (debut !== undefined) {
                localVarQueryParameter['debut'] = (debut as any instanceof Date) ?
                    (debut as any).toISOString().substring(0,10) :
                    debut;
            }

            if (fin !== undefined) {
                localVarQueryParameter['fin'] = (fin as any instanceof Date) ?
                    (fin as any).toISOString().substring(0,10) :
                    fin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary obtenir le graphe de projection d\'un patrimoine sur une plage de date donnée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} [debut] 
         * @param {string} [fin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineGraph: async (nomPatrimoine: string, debut?: string, fin?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getPatrimoineGraph', 'nomPatrimoine', nomPatrimoine)
            const localVarPath = `/patrimoines/{nom_patrimoine}/graphe`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (debut !== undefined) {
                localVarQueryParameter['debut'] = (debut as any instanceof Date) ?
                    (debut as any).toISOString().substring(0,10) :
                    debut;
            }

            if (fin !== undefined) {
                localVarQueryParameter['fin'] = (fin as any instanceof Date) ?
                    (fin as any).toISOString().substring(0,10) :
                    fin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectionFutureApi - functional programming interface
 * @export
 */
export const ProjectionFutureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectionFutureApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary obtenir une liste des flux impossibles du patrimoine dans une intervalle donnée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} [debut] 
         * @param {string} [fin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoineFluxImpossibles(nomPatrimoine: string, debut?: string, fin?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPatrimoineFluxImpossibles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoineFluxImpossibles(nomPatrimoine, debut, fin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectionFutureApi.getPatrimoineFluxImpossibles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary obtenir le graphe de projection d\'un patrimoine sur une plage de date donnée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} [debut] 
         * @param {string} [fin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoineGraph(nomPatrimoine: string, debut?: string, fin?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoineGraph(nomPatrimoine, debut, fin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectionFutureApi.getPatrimoineGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectionFutureApi - factory interface
 * @export
 */
export const ProjectionFutureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectionFutureApiFp(configuration)
    return {
        /**
         * 
         * @summary obtenir une liste des flux impossibles du patrimoine dans une intervalle donnée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} [debut] 
         * @param {string} [fin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineFluxImpossibles(nomPatrimoine: string, debut?: string, fin?: string, options?: any): AxiosPromise<GetPatrimoineFluxImpossibles200Response> {
            return localVarFp.getPatrimoineFluxImpossibles(nomPatrimoine, debut, fin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary obtenir le graphe de projection d\'un patrimoine sur une plage de date donnée
         * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
         * @param {string} [debut] 
         * @param {string} [fin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineGraph(nomPatrimoine: string, debut?: string, fin?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPatrimoineGraph(nomPatrimoine, debut, fin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectionFutureApi - object-oriented interface
 * @export
 * @class ProjectionFutureApi
 * @extends {BaseAPI}
 */
export class ProjectionFutureApi extends BaseAPI {
    /**
     * 
     * @summary obtenir une liste des flux impossibles du patrimoine dans une intervalle donnée
     * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {string} [debut] 
     * @param {string} [fin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectionFutureApi
     */
    public getPatrimoineFluxImpossibles(nomPatrimoine: string, debut?: string, fin?: string, options?: RawAxiosRequestConfig) {
        return ProjectionFutureApiFp(this.configuration).getPatrimoineFluxImpossibles(nomPatrimoine, debut, fin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary obtenir le graphe de projection d\'un patrimoine sur une plage de date donnée
     * @param {string} nomPatrimoine nom du patrimoine avec les espaces remplacés par \&quot;_\&quot; s\&#39;il y en a
     * @param {string} [debut] 
     * @param {string} [fin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectionFutureApi
     */
    public getPatrimoineGraph(nomPatrimoine: string, debut?: string, fin?: string, options?: RawAxiosRequestConfig) {
        return ProjectionFutureApiFp(this.configuration).getPatrimoineGraph(nomPatrimoine, debut, fin, options).then((request) => request(this.axios, this.basePath));
    }
}



